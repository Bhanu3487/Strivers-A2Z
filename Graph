#include <iostream>
using namespace std;

// AM - space complexity issues - use AL
// stack - using stack data structure(same as bfs) and using resursion (can also do backtracing)

// learning
// Q1 - num of graphs possible with n vertices - ans: pow(2,(n*(n-1))/2) - check using adj matrix

// Q2,3 - convert edges to al edges -> am -> al - tle 
vector<vector<int>> printGraph(int V, vector<pair<int,int>>edges) {
    vector<vector<int>> am(V, vector<int>(V,0));
    vector<vector<int>> al(V);
    
    for(auto edge: edges){
        am[edge.first][edge.second] = 1;
        am[edge.second][edge.first] = 1;
    }
    
    for(int i = 0; i < V; i++){
        for(int j = 0; j < V; j++){
            if(am[i][j]) al[i].push_back(j);
        }
    }
    return al;
}

// better mothod - edges to al
vector<vector<int>> printGraph(int V, vector<pair<int,int>>edges) {
    vector<vector<int>> al(V);
    
    for(auto edge: edges){
        al[edge.first].push_back(edge.second);
        al[edge.second].push_back(edge.first);
    }

    return al;
}

// Q4 - connected components (in a disconnected graphs)
// to traversal in a disconnected graph - keep trach of visited vertices.
for(auto v: V){
    if(!visited(v)) traversal(v)        //visited is and arr and traversal is a func 
}

// Q5 Function to return Breadth First Traversal of given graph.
vector<int> bfsOfGraph(int V, vector<int> adj[]) {
    queue<int> q;
    vector<bool> visited(V,false);
    vector<int> bfs;
    
    q.push(0);
    visited[0] = true;

    while(!q.empty()){
        int v = q.front();
        q.pop();
        bfs.push_back(v);
    
        for(int i: adj[v]){
            if(!visited[i]) {
                q.push(i);
                visited[i] = true;
            }
        }
    }
    
    return bfs;
}

// Q6 Function to return a list containing the DFS traversal of the graph.
vector<int> dfsOfGraph(int V, vector<int> adj[]) {
    vector<int> dfs;
    vector<int> visited(V, false);
    stack<int> st;
    
    st.push(0);
    
    while(!st.empty()){
        int v = st.top();
        st.pop();
        if(!visited[v]) {
            dfs.push_back(v);
            visited[v] = true;
        }
        
        for(int i = adj[v].size()-1; i >= 0; i--){
            if(!visited[adj[v][i]]){
                st.push(adj[v][i]);
            }
        }
    }
    return dfs;
}

// traversal
// Q1 - num of connected componets
// time:O(n^2)95%, space:O(n)58%
class Solution {
public:
    int check(vector<bool>& visited){
        for(int i = 0; i < visited.size(); i++){
            if(visited[i] == false) return i;
        }
        return -1;
    }

    int findCircleNum(vector<vector<int>>& edges) {
        int n = edges.size();
        queue<int> q;
        vector<bool> visited(n, false);
        int ans = 0;

        int c = check(visited);
        while(c != -1){
            q.push(c);
            visited[c] = true;
            ans++;
            
            while(!q.empty()){
                int v = q.front();
                q.pop();
                
                for(int u = 0; u < n; u++){
                    if(edges[v][u] == 1 && visited[u] == false){
                        q.push(u);
                        visited[u] = true;
                    }
                }
            }
            
            c = check(visited);
        }
        return ans;
    }
};

// time:O(n^2)60%, space:O(n)5%
class Solution {
public:
    void bfsOfGraph(int v, vector<vector<int>> adj, vector<bool>& visited) {        
        queue<int> q;
        q.push(v);
        visited[v] = true;

        while(!q.empty()){
            int v = q.front();
            q.pop();
        
            for(int u = 0; u < adj.size(); u++){
                if(!visited[u] && adj[v][u] == 1) {
                    q.push(u);
                    visited[u] = true;
                }
            }
        }
        return;
    }

    int findCircleNum(vector<vector<int>>& edges) {
        vector<bool> visited(edges.size(),false);
        int ans = 0;
        for(int i = 0; i < edges.size(); i++){
            if(visited[i] == false) {bfsOfGraph(i, edges, visited); ans++;}
        }
        return ans;
    }
};

// Q3 - rotten oranges - the fresh tomatoes around rotten tomatoes get rotten, in how much time will all tomatoes rot
// 1.30, time:O(n^2) 100, space:O(n) 9
class Solution {
public:
    void bfs(vector<vector<int>>& grid, vector<bool>& vis, vector<int>& dis, vector<int>& rot){
        int n = grid.size();
        int m = grid[0].size();
        queue<int> q;

        for(int r: rot) {q.push(r); vis[r] = true;}

        while(!q.empty()){
            int v = q.front(); q.pop();
            int r = v/m, c = v%m;

            cout<<v << " " <<r<<" "<<c;
            
            if(r > 0 && vis[m*(r-1)+c] == false){
                if(grid[r-1][c] == 0 || grid[r-1][c] == 2) vis[m*(r-1)+c] = true;
                else{
                    q.push(m*(r-1)+c);
                    vis[m*(r-1)+c] = true;
                    dis[m*(r-1)+c] = 1 + dis[v];
                }
            }

            if(r != n-1 && vis[m*(r+1)+c] == false){
                if(grid[r+1][c] == 0 || grid[r+1][c] == 2) vis[m*(r+1)+c] = true;
                else{
                    q.push(m*(r+1)+c);
                    vis[m*(r+1)+c] = true;
                    dis[m*(r+1)+c] = 1 + dis[v];
                }
            }  

            if(c != m-1 && vis[m*r+(c+1)] == false){
                if(grid[r][c+1] == 0 || grid[r][c+1] == 2) vis[m*r+(c+1)] = true;
                else{
                    q.push(m*r+(c+1));
                    vis[m*r+(c+1)] = true;
                    dis[m*r+(c+1)] = 1 + dis[v];
                }
            }   

            if(c > 0 && vis[m*r+(c-1)] == false){
                if(grid[r][c-1] == 0 || grid[r][c-1] == 2) vis[m*r+(c-1)] = true;
                else{
                    q.push(m*r+(c-1));
                    vis[m*r+(c-1)] = true;
                    dis[m*r+(c-1)] = 1 + dis[v];
                }
            }         
        }
    }

    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<bool> vis(n*m, false);
        vector<int> dis(n*m, 0);

        int flag = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 1) {flag = 1; break;}
            }
        }
        if(flag == 0)return 0;

        vector<int> rot;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 2) rot.push_back(m*i+j);
            }
        }
        if(rot.size() == 0)return -1;
        bfs(grid, vis, dis, rot);

        int d = INT_MIN;
        for(int i = 0; i < n*m; i++){
            if(d < dis[i]) d = dis[i];
            if(vis[i] == false && grid[i/m][i%m] == 1)return -1;
        }

        return d;
    }
};

// 85, 15
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> dis(n, vector<int>(m,0));
        queue<pair<int,int>> q;

        int fresh = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 2) q.push(make_pair(i,j)); 
                if(grid[i][j] == 1) fresh = 1;
            }
        }
        if(fresh == 0)return 0;
        if(q.empty())return -1;

        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,-1,0,1};

        while(!q.empty()){
            int r = q.front().first;
            int c = q.front().second;
            q.pop();

            for (int i = 0; i < 4; i++) {
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] == 1) {
                    q.push(make_pair(nr, nc));
                    grid[nr][nc] = 2;  
                    dis[nr][nc] = dis[r][c] + 1;
                }
            }
        }
        
        int d = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 1) return -1;
                d = max(d, dis[i][j]);
            }
        }

        return d;
    }
};

// Q4 flood fill, hiven source and req clr and start clr - from source any pixel with start clr gets converted to req clr and ro return the final clrs
class Solution {
private:
    void dfs(int row, int col, vector<vector<int>>& ans,vector<vector<int>>& image,int iniColor, int newColor, int delRow[], int delCol[]){
        ans[row][col] = newColor;
        for(int i = 0; i < 4; i++){
            int nrow = row + delRow[i];
            int ncol = col + delCol[i];
            if(nrow >= 0 && nrow < image.size() && ncol >= 0 && ncol < image[0].size() && image[nrow][ncol] == iniColor && ans[nrow][ncol] != newColor){
                dfs(nrow, ncol, ans, image, iniColor, newColor, delRow, delCol);
            }
        }
    }

public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int iniColor = image[sr][sc];
        vector<vector<int>> ans = image;
        int delRow[] = {-1, 0 ,1, 0};
        int delCol[] = {0, 1, 0, -1};
        dfs(sr, sc, ans, image, iniColor, color, delRow, delCol);
        return ans;
    }
};

// Q5 cycle detection - dfs
class Solution{
  public:
    int dfs(int V, vector<int> adj[], vector<bool>& vis, int r){
        stack<int> st;
        st.push(r);
        vector<bool> vis2(V, false);
        vector<int> par(V, -1);
        vis[r] = true; vis2[r] = true;par[r] = r;
        
        while(!st.empty()){
            int v = st.top(); st.pop();
            
            for(int u: adj[v]){
                if(vis2[u] && u!=v && u != par[v]) return 1;
                if(!vis[u]){
                    st.push(u);
                    vis[u] = true; vis2[u] = true;
                    par[u] = v;
                }
            }
        }
        return 0;
    }
    
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool> vis(V, false);
        
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(V, adj, vis, i))return 1;
        }
        return 0;
    }
};

class Solution{
 private:
    bool dfs(int v, int par, vector<bool>&vis, vector<int> adj[]){
        vis[v] = true;
        for(auto u: adj[v]){
            if(!vis[u]) {if(dfs(u, v, vis, adj)) return true;}
            else if(u != par) return true;
        }
        return false;
    }
    
  public:
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool> vis(V, false);
        
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(i, -1, vis, adj))return true;
        }
        return false;
    }
};

// Cycle detection - bfs - rep stack with queue in dfs
// time: O(V + 2E) (2E = sum(degree) = sum(adj edges) in undir graph)
// queue :O(V) - queue and vis and par
class Solution{
public:
    int dfs(int V, vector<int> adj[], vector<bool>& vis, int r){
        queue<int> q;
        q.push(r);
        vector<bool> vis2(V, false);
        vector<int> par(V, -1);
        vis[r] = true; vis2[r] = true;par[r] = r;
        
        while(!q.empty()){
            int v = q.front(); q.pop();
            
            for(int u: adj[v]){
                if(vis2[u] && u!=v && u != par[v]) return 1;
                if(!vis[u]){
                    q.push(u);
                    vis[u] = true; vis2[u] = true;
                    par[u] = v;
                }
            }
        }
        return 0;
    }
    
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool> vis(V, false);
        
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(V, adj, vis, i))return 1;
        }
        return 0;
    }
};


// Q8 - surrounding region, find all the connected regions in contect with the edges, keep these unaffected, and convert the remaining regions
// time :O(V+2E => (n*m) + 2*n*m) dfs + O(n*m) - 33, space:O()ASS - 7
class Solution {
public:
    void dfs(vector<vector<char>>& board, int r, int c){
        if(board[r][c] == 'x' || board[r][c] == 'X')return;
        int n = board.size();
        int m = board[0].size();
        
        board[r][c] = 'x';
        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,-1,0,1};

        for(int i = 0; i < 4; i++){
            int nr = r+dr[i], nc = c+dc[i];
            if(nr < n && nc < m && nr >= 0 && nc >= 0) {
                dfs(board, nr, nc);
            }
        }
        return;
    }

    void solve(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();
        
        for(int i = 0; i < n; i++){
            if(board[i][0] == 'O') dfs(board, i, 0);
            if(board[i][m-1] == 'O') dfs(board, i, m-1);
        }

        for(int i = 1; i < m-1; i++){
            if(board[0][i] == 'O') dfs(board, 0, i);
            if(board[n-1][i] == 'O') dfs(board, n-1, i);
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(board[i][j] == 'O')board[i][j] = 'X';
                if(board[i][j] == 'x')board[i][j] = 'O';
            }
        }

        return;
    }
};

// Q9 - flood fill - same as above q
// time:5, space:5
class Solution {
public:
    void dfs(vector<vector<int>>& board, int r, int c){
        if(board[r][c] == 0)return;
        int n = board.size();
        int m = board[0].size();
        
        board[r][c] = 0;
        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,-1,0,1};

        for(int i = 0; i < 4; i++){
            int nr = r+dr[i], nc = c+dc[i];
            if(nr < n && nc < m && nr >= 0 && nc >= 0) {
                dfs(board, nr, nc);
            }
        }
        return;
    }

    int numEnclaves(vector<vector<int>>& board) {
        int n = board.size();
        int m = board[0].size();
        
        for(int i = 0; i < n; i++){
            if(board[i][0] == 1) dfs(board, i, 0);
            if(board[i][m-1] == 1) dfs(board, i, m-1);
        }

        for(int i = 1; i < m-1; i++){
            if(board[0][i] == 1) dfs(board, 0, i);
            if(board[n-1][i] == 1) dfs(board, n-1, i);
        }

        int ans = 0;
        for(int i = 1; i < n-1; i++){
            for(int j = 1; j < m-1; j++){
                if(board[i][j] == 1) ans++;
            }
        }

        return ans;
    }
};

// same code as above but 40, 60
class Solution {
public:
    void dfs(vector<vector<int>>& grid,int i,int j,int m,int n){
        if(i<0 || i >=m || j<0 || j>=n || grid[i][j] == 0 || grid[i][j] == 2) return;
        grid[i][j] = 2;
        int ai[] = {0,1,0,-1};
        int aj[] = {1,0,-1,0};

        for(int k=0;k<4;k++){
            dfs(grid,i+ai[k],j+aj[k],m,n);
        }
    }
    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        for(int i=0;i<m;i++){
            dfs(grid,i,0,m,n);
            dfs(grid,i,n-1,m,n);
        }
        for(int i=0;i<n;i++){
            dfs(grid,0,i,m,n);
            dfs(grid,m-1,i,m,n);
        }

        int count = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1) count++;
            }
        }

        return count;
    }
};

// Q13
// time:O(V+2E) 85, space:O(V) 20
class Solution {
public:
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> cls(n,-1);

        for(int i = 0; i < n; i++){
            if(cls[i] == -1){
                queue<int> q;
                cls[i] = i;
                q.push(i);

                while(!q.empty()){
                    int v = q.front(); q.pop();

                    for(int u: graph[v]){
                        if(cls[u] == cls[v]) return false;
                        else if(cls[u] == -1) {cls[u] = cls[v]^1; q.push(u);}
                    }
                }
            }
        }
        
        return true;
    }
};

// Q14- cycle detection in directed graph - using dfs (using bfs in toposort)
class Solution {
public:
    bool dfs(int v, vector<bool>& vis, vector<bool>& pathVis, vector<int> adj[]){
        vis[v] = true;
        pathVis[v] = true;
        for(int u: adj[v]){
            if(!vis[u]) {
                if(dfs(u, vis, pathVis, adj)) return true;
            } else if(pathVis[u]) return true;
        }
        pathVis[v] = false;
        return false;
    }

    bool isCyclic(int V, vector<int> adj[]) {
        vector<bool> vis(V,false);
        vector<bool> pathVis(V,false);
        
        //traverse all components(connected and disconnnected)
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(i, vis, pathVis, adj)) return true;
        }
        return false;
    }
};

// 3. TOPOSORT and Problems---------------------------------------
// actual Q14 - topological sort
// time: O(E+V) - dfs and create adj 25, space:O(V+E) - stack vis, adj, 35
class Solution {
public:
    bool dfs(int v, vector<int>& vis, vector<int>& pathVis, stack<int>& s, vector<vector<int>>& adj){
        vis[v] = 1;
        pathVis[v] = 1;
        for(auto u:adj[v]){
            if(pathVis[u]) return false;
            if(!vis[u]) if(!dfs(u, vis, pathVis, s, adj)) return false;
        }
        
        s.push(v);
        pathVis[v] = 0;
        return true;
    }

    vector<int> findOrder(int V, vector<vector<int>>& edges) {
        vector<vector<int>>adj(V);
        for(int i = 0; i < edges.size(); i++){
            adj[edges[i][1]].push_back(edges[i][0]);
        }

        vector<int> vis(V,0);
        vector<int> pathVis(V,0);
        stack<int> s;

        for(int i = 0; i < V; i++){
            if(!vis[i]) if(!dfs(i, vis, pathVis, s, adj)) return vector<int>{};
        }

        vector<int> ans;
        while(!s.empty()){
            ans.push_back(s.top());
            s.pop();
        }
        
        return ans;
    }
};

// Q2 kahn's algorithm
// using bfs and checking prereq - same idea
// --------replacing queue with stack in the below code - time:30
// because bfs all the prereq courses are done first and so on, but in dfs do traverse te paths - not ideal
// time: O(V+E)-bfs,adj 90%, space:O(V+E) 60% indeg, queue
class Solution {
public:
    vector<int> findOrder(int N, vector<vector<int>>& edges) {
        vector<vector<int>> adj(N);                   // {prerequisite-course : [list of next courses]}
        vector<int> ans, indegree(N);               // indegree[i] denotes number of prerequisite courses for ith course
        for(auto& edge : edges) 
            adj[edge[1]].push_back(edge[0]),            // forming adjacency list graph
            indegree[edge[0]]++;                     
        
        queue<int> q;
        for(int i = 0; i < N; i++)
            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites
        
        while(!q.empty()) {
            auto v = q.front(); q.pop();
            ans.push_back(v);                     // cur has no remaining pre courses, so we can take it now
            for(auto u : adj[v]) 
                if(--indegree[u] == 0)     // if there's a next course having 0 prequisite remaining,
                    q.push(u);             // then we can take it
        }

        if(size(ans) == N) return ans;              // ordering exists where all courses can be finished
        return {};                                      
    }
};

// Q3. cyle detection - directed graph
class Solution{
  public:
    bool isCyclic(int V, vector<int> adj[]) {
        vector<int> ans, indegree(V);               // indegree[i] denotes number of prerequisite courses for ith course
        for(int v = 0; v < V; v++){
            for(int u : adj[v]) indegree[u]++;
        }
        
        queue<int> q;
        for(int i = 0; i < V; i++)
            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites
        
        while(!q.empty()) {
            auto v = q.front(); q.pop();
            ans.push_back(v);                     // cur has no remaining pre courses, so we can take it now
            for(auto u : adj[v]) 
                if(--indegree[u] == 0)     // if there's a next course having 0 prequisite remaining,
                    q.push(u);             // then we can take it
        }

        if(ans.size() == V) return 0;              // ordering exists where all courses can be finished
        return 1;      
    }
};

// Q4, Q5 - course shecule same as Q2 ; 50, 70

// Q6 - find safe vertices - a vertex is safe if all paths starting from it end at a terminal (a vertex with no outgoing edges)
// have a safe arr which tracks safe nodes (1=safe, 0=not vis or not safe) so in dfs check for
// 1. (vis and !safe) => not safe => return false and 2. (!safe) => not known => if(!dfs(u)) => not safe and 3. if not above - it is safe => only after checking all neighbours and paths, we can decide if it is safe or not
// time: O(V+E) 85, space: O(V+E) 80 - bc dfs
class Solution {
public:
    bool dfs(int v, vector<bool>& safe, vector<bool>& vis, vector<bool>& pathVis, vector<vector<int>>& graph){
        vis[v] = true; pathVis[v] = true;
        for(int u : graph[v]){
            if(safe[u] == 0 && vis[u]) return false;
            else if(safe[u] == 0){
                if(pathVis[u]) return false;
                if(!dfs(u, safe, vis, pathVis, graph)) {safe[u] = 0; return false;} 
            }
        }
        safe[v] = 1;
        pathVis[v] = false;
        return true;
    }

    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int V = graph.size();
        vector<bool> vis(V,false);
        vector<bool> pathVis(V,false);
        vector<bool> safe(V,0);
        vector<int> ans;

        for(int i = 0; i < V; i++){
            if(graph[i].size() == 0) {safe[i] = true;}
        }

        for(int i = 0; i < V; i++){
            if(!vis[i]) dfs(i, safe, vis, pathVis, graph);
            if(safe[i])ans.push_back(i);
        }
        
        return ans;
    }
};

