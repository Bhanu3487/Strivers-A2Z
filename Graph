#include <iostream>
using namespace std;

// AM - space complexity issues - use AL
// dfs - using stack data structure(same as bfs) and using resursion (can also do backtracing)
// dfs - the traversal order is seen when poping, in bfs the traversal order is seen when pushing q5 and q6 in learning
// dfs is slower than bfs (bfs gets into the queue in that order and gets excecuted neatly) - don't write a separate bfs function (auxilary stack space) whearas for dfs its better?

// 4. shortest path from a node to all points
// undirected unit weight - sime bfs
// undirected weighted - dijkstras          // directed weighted acylcic - simple bfs/ toposort with bfs

// learning
// Q1 - num of graphs possible with n vertices - ans: pow(2,(n*(n-1))/2) - check using adj matrix

// Q2,3 - convert edges to al edges -> am -> al - tle 
vector<vector<int>> printGraph(int V, vector<pair<int,int>>edges) {
    vector<vector<int>> am(V, vector<int>(V,0));
    vector<vector<int>> al(V);
    
    for(auto edge: edges){
        am[edge.first][edge.second] = 1;
        am[edge.second][edge.first] = 1;
    }
    
    for(int i = 0; i < V; i++){
        for(int j = 0; j < V; j++){
            if(am[i][j]) al[i].push_back(j);
        }
    }
    return al;
}

// better method - edges to al
vector<vector<int>> printGraph(int V, vector<pair<int,int>>edges) {
    vector<vector<int>> al(V);
    
    for(auto edge: edges){
        al[edge.first].push_back(edge.second);
        al[edge.second].push_back(edge.first);
    }

    return al;
}

// Q4 - connected components (in a disconnected graphs)
// to traversal in a disconnected graph - keep track of visited vertices.
for(auto v: V){
    if(!visited[v]) traversal(v)        //visited is and arr and traversal is a func 
}

// Q5 Function to return Breadth First Traversal of given graph.
vector<int> bfsOfGraph(int V, vector<int> adj[]) {
    queue<int> q;
    vector<bool> visited(V,false);
    vector<int> bfs;
    
    q.push(0);
    visited[0] = true;

    while(!q.empty()){
        int v = q.front();
        q.pop();
        bfs.push_back(v);
    
        for(int i: adj[v]){
            if(!visited[i]) {
                q.push(i);
                visited[i] = true;
            }
        }
    }
    
    return bfs;
}

// Q6 Function to return a list containing the DFS traversal of the graph.
vector<int> dfsOfGraph(int V, vector<int> adj[]) {
    vector<int> dfs;
    vector<int> visited(V, false);
    stack<int> st;
    
    st.push(0);
    
    while(!st.empty()){
        int v = st.top();
        st.pop();
        if(!visited[v]) {
            dfs.push_back(v);
            visited[v] = true;
        }
        
        // bcz we need to traverse the paths in a order from left to right
        for(int i = adj[v].size()-1; i >= 0; i--){
            if(!visited[adj[v][i]]){
                st.push(adj[v][i]);
            }
        }
    }
    return dfs;
}

// 2. traversal---------------------------------------------
// Q1 - num of connected componets

// dfs time: O(V+2E)22, space:O() 60
class Solution {
public:
    int findCircleNum(vector<vector<int>>& edges) {
        int n = edges.size();
        stack<int> s;
        vector<bool> visited(n, false);
        int ans = 0;

        for(int i = 0; i < n; i++){
            if(!visited[i]){
                s.push(i);
                visited[i] = true;
                ans++;
            }

            while(!s.empty()){
                int v = s.top();s.pop();
                
                for(int u = 0; u < n; u++){
                    if(edges[v][u] == 1 && visited[u] == false){
                        s.push(u);
                        visited[u] = true;
                    }
                }
            }
        }

        return ans;
    }
};

// time:O(n^2)95%, space:O(n)58%
class Solution {
public:
    int check(vector<bool>& visited){
        for(int i = 0; i < visited.size(); i++){
            if(visited[i] == false) return i;
        }
        return -1;
    }

    int findCircleNum(vector<vector<int>>& edges) {
        int n = edges.size();
        queue<int> q;
        vector<bool> visited(n, false);
        int ans = 0;

        int c = check(visited);
        while(c != -1){
            q.push(c);
            visited[c] = true;
            ans++;
            
            while(!q.empty()){
                int v = q.front();
                q.pop();
                
                for(int u = 0; u < n; u++){
                    if(edges[v][u] == 1 && visited[u] == false){
                        q.push(u);
                        visited[u] = true;
                    }
                }
            }
            
            c = check(visited);
        }
        return ans;
    }
};

// time:O(n^2)60%, space:O(n)5%
class Solution {
public:
    void bfsOfGraph(int v, vector<vector<int>> adj, vector<bool>& visited) {        
        queue<int> q;
        q.push(v);
        visited[v] = true;

        while(!q.empty()){
            int v = q.front();
            q.pop();
        
            for(int u = 0; u < adj.size(); u++){
                if(!visited[u] && adj[v][u] == 1) {
                    q.push(u);
                    visited[u] = true;
                }
            }
        }
        return;
    }

    int findCircleNum(vector<vector<int>>& edges) {
        vector<bool> visited(edges.size(),false);
        int ans = 0;
        for(int i = 0; i < edges.size(); i++){
            if(visited[i] == false) {bfsOfGraph(i, edges, visited); ans++;}
        }
        return ans;
    }
};

// Q3 - rotten oranges - the fresh tomatoes around rotten tomatoes get rotten, in how much time will all tomatoes rot
// 1.30, time:O(n*m) 100, space:O(n*m) 9
class Solution {
public:
    void bfs(vector<vector<int>>& grid, vector<bool>& vis, vector<int>& dis, vector<int>& rot){
        int n = grid.size();
        int m = grid[0].size();
        queue<int> q;

        for(int r: rot) {q.push(r); vis[r] = true;}

        while(!q.empty()){
            int v = q.front(); q.pop();
            int r = v/m, c = v%m;

            cout<<v << " " <<r<<" "<<c;
            
            if(r > 0 && vis[m*(r-1)+c] == false){
                if(grid[r-1][c] == 0 || grid[r-1][c] == 2) vis[m*(r-1)+c] = true;
                else{
                    q.push(m*(r-1)+c);
                    vis[m*(r-1)+c] = true;
                    dis[m*(r-1)+c] = 1 + dis[v];
                }
            }

            if(r != n-1 && vis[m*(r+1)+c] == false){
                if(grid[r+1][c] == 0 || grid[r+1][c] == 2) vis[m*(r+1)+c] = true;
                else{
                    q.push(m*(r+1)+c);
                    vis[m*(r+1)+c] = true;
                    dis[m*(r+1)+c] = 1 + dis[v];
                }
            }  

            if(c != m-1 && vis[m*r+(c+1)] == false){
                if(grid[r][c+1] == 0 || grid[r][c+1] == 2) vis[m*r+(c+1)] = true;
                else{
                    q.push(m*r+(c+1));
                    vis[m*r+(c+1)] = true;
                    dis[m*r+(c+1)] = 1 + dis[v];
                }
            }   

            if(c > 0 && vis[m*r+(c-1)] == false){
                if(grid[r][c-1] == 0 || grid[r][c-1] == 2) vis[m*r+(c-1)] = true;
                else{
                    q.push(m*r+(c-1));
                    vis[m*r+(c-1)] = true;
                    dis[m*r+(c-1)] = 1 + dis[v];
                }
            }         
        }
    }

    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<bool> vis(n*m, false);
        vector<int> dis(n*m, 0);

        int flag = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 1) {flag = 1; break;}
            }
        }
        if(flag == 0)return 0;

        vector<int> rot;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 2) rot.push_back(m*i+j);
            }
        }
        if(rot.size() == 0)return -1;
        bfs(grid, vis, dis, rot);

        int d = INT_MIN;
        for(int i = 0; i < n*m; i++){
            if(d < dis[i]) d = dis[i];
            if(vis[i] == false && grid[i/m][i%m] == 1)return -1;
        }

        return d;
    }
};

// 85, 15
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> dis(n, vector<int>(m,0));
        queue<pair<int,int>> q;

        int fresh = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 2) q.push(make_pair(i,j)); 
                if(grid[i][j] == 1) fresh = 1;
            }
        }
        if(fresh == 0)return 0;
        if(q.empty())return -1;

        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,-1,0,1};

        while(!q.empty()){
            int r = q.front().first;
            int c = q.front().second;
            q.pop();

            for (int i = 0; i < 4; i++) {
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] == 1) {
                    q.push(make_pair(nr, nc));
                    grid[nr][nc] = 2;  
                    dis[nr][nc] = dis[r][c] + 1;
                }
            }
        }
        
        int d = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 1) return -1;
                d = max(d, dis[i][j]);
            }
        }

        return d;
    }
};

// Q4 flood fill, hiven source and req clr and start clr - from source any pixel with start clr gets converted to req clr and ro return the final clrs
// 45,60
class Solution {
private:
    void dfs(int row, int col, vector<vector<int>>& ans,vector<vector<int>>& image,int iniColor, int newColor, int delRow[], int delCol[]){
        if(ans[row][col] != newColor){      // mem % inc by 15 when added this line
            ans[row][col] = newColor;
            for(int i = 0; i < 4; i++){
                int nrow = row + delRow[i];
                int ncol = col + delCol[i];
                if(nrow >= 0 && nrow < image.size() && ncol >= 0 && ncol < image[0].size() && image[nrow][ncol] == iniColor && ans[nrow][ncol] != newColor){
                    dfs(nrow, ncol, ans, image, iniColor, newColor, delRow, delCol);
                }
            }
        }
    }

public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int iniColor = image[sr][sc];
        vector<vector<int>> ans = image;
        int delRow[] = {-1, 0 ,1, 0};
        int delCol[] = {0, 1, 0, -1};
        dfs(sr, sc, ans, image, iniColor, color, delRow, delCol);
        return ans;
    }
};

// Q5 cycle detection - dfs - can also use bfs - queue
class Solution{
  public:
    int dfs(int V, vector<int> adj[], vector<bool>& vis, int r){
        stack<int> st;
        st.push(r);
        vector<bool> vis2(V, false);
        vector<int> par(V, -1);
        vis[r] = true; vis2[r] = true;par[r] = r;
        
        while(!st.empty()){
            int v = st.top(); st.pop();
            
            for(int u: adj[v]){
                if(vis2[u] && u!=v && u != par[v]) return 1;
                if(!vis[u]){
                    st.push(u);
                    vis[u] = true; vis2[u] = true;
                    par[u] = v;
                }
            }
        }
        return 0;
    }
    
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool> vis(V, false);
        
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(V, adj, vis, i))return 1;
        }
        return 0;
    }
};

// can be done with pathVis - i think this is better with just 1 var par
class Solution{
 private:
    bool dfs(int v, int par, vector<bool>&vis, vector<int> adj[]){
        vis[v] = true;
        for(auto u: adj[v]){
            if(!vis[u]) {if(dfs(u, v, vis, adj)) return true;}
            else if(u != par) return true;
        }
        return false;
    }
    
  public:
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool> vis(V, false);
        
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(i, -1, vis, adj))return true;
        }
        return false;
    }
};

// Cycle detection - bfs - rep stack with queue in dfs
// time: O(V + 2E) (2E = sum(degree) = sum(adj edges) in undir graph)
// queue :O(V) - queue and vis and par
class Solution{
public:
    int dfs(int V, vector<int> adj[], vector<bool>& vis, int r){
        queue<int> q;
        q.push(r);
        vector<bool> vis2(V, false);
        vector<int> par(V, -1);
        vis[r] = true; vis2[r] = true;par[r] = r;
        
        while(!q.empty()){
            int v = q.front(); q.pop();
            
            for(int u: adj[v]){
                if(vis2[u] && u!=v && u != par[v]) return 1;
                if(!vis[u]){
                    q.push(u);
                    vis[u] = true; vis2[u] = true;
                    par[u] = v;
                }
            }
        }
        return 0;
    }
    
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool> vis(V, false);
        
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(V, adj, vis, i))return 1;
        }
        return 0;
    }
};


// Q8 - surrounding region, find all the connected regions in contect with the edges, keep these unaffected, and convert the remaining regions
// time :O(V+2E => (n*m) + 2*n*m) dfs + O(n*m) - 33, space:O()ASS - 7
class Solution {
public:
    void dfs(vector<vector<char>>& board, int r, int c){
        if(board[r][c] == 'x' || board[r][c] == 'X')return;
        int n = board.size();
        int m = board[0].size();
        
        board[r][c] = 'x';
        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,-1,0,1};

        for(int i = 0; i < 4; i++){
            int nr = r+dr[i], nc = c+dc[i];
            if(nr < n && nc < m && nr >= 0 && nc >= 0) {
                dfs(board, nr, nc);
            }
        }
        return;
    }

    void solve(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();
        
        for(int i = 0; i < n; i++){
            if(board[i][0] == 'O') dfs(board, i, 0);
            if(board[i][m-1] == 'O') dfs(board, i, m-1);
        }

        for(int i = 1; i < m-1; i++){
            if(board[0][i] == 'O') dfs(board, 0, i);
            if(board[n-1][i] == 'O') dfs(board, n-1, i);
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(board[i][j] == 'O')board[i][j] = 'X';
                if(board[i][j] == 'x')board[i][j] = 'O';
            }
        }

        return;
    }
};

// Q9 - flood fill - same as above q
// time:5, space:5
class Solution {
public:
    void dfs(vector<vector<int>>& board, int r, int c){
        if(board[r][c] == 0)return;
        int n = board.size();
        int m = board[0].size();
        
        board[r][c] = 0;
        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,-1,0,1};

        for(int i = 0; i < 4; i++){
            int nr = r+dr[i], nc = c+dc[i];
            if(nr < n && nc < m && nr >= 0 && nc >= 0) {
                dfs(board, nr, nc);
            }
        }
        return;
    }

    int numEnclaves(vector<vector<int>>& board) {
        int n = board.size();
        int m = board[0].size();
        
        for(int i = 0; i < n; i++){
            if(board[i][0] == 1) dfs(board, i, 0);
            if(board[i][m-1] == 1) dfs(board, i, m-1);
        }

        for(int i = 1; i < m-1; i++){
            if(board[0][i] == 1) dfs(board, 0, i);
            if(board[n-1][i] == 1) dfs(board, n-1, i);
        }

        int ans = 0;
        for(int i = 1; i < n-1; i++){
            for(int j = 1; j < m-1; j++){
                if(board[i][j] == 1) ans++;
            }
        }

        return ans;
    }
};

// same code as above but 40, 60
class Solution {
public:
    void dfs(vector<vector<int>>& grid,int i,int j,int m,int n){
        if(i<0 || i >=m || j<0 || j>=n || grid[i][j] == 0 || grid[i][j] == 2) return;
        grid[i][j] = 2;
        int ai[] = {0,1,0,-1};
        int aj[] = {1,0,-1,0};

        for(int k=0;k<4;k++){
            dfs(grid,i+ai[k],j+aj[k],m,n);
        }
    }
    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        for(int i=0;i<m;i++){
            dfs(grid,i,0,m,n);
            dfs(grid,i,n-1,m,n);
        }
        for(int i=0;i<n;i++){
            dfs(grid,0,i,m,n);
            dfs(grid,m-1,i,m,n);
        }

        int count = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1) count++;
            }
        }

        return count;
    }
};

// Q13
// time:O(V+2E) 85, space:O(V) 20
class Solution {
public:
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> cls(n,-1);

        for(int i = 0; i < n; i++){
            if(cls[i] == -1){
                queue<int> q;
                cls[i] = i;
                q.push(i);

                while(!q.empty()){
                    int v = q.front(); q.pop();

                    for(int u: graph[v]){
                        if(cls[u] == cls[v]) return false;
                        else if(cls[u] == -1) {cls[u] = cls[v]^1; q.push(u);}
                    }
                }
            }
        }
        
        return true;
    }
};

// Q14- cycle detection in directed graph - using dfs (using bfs in toposort)
class Solution {
public:
    bool dfs(int v, vector<bool>& vis, vector<bool>& pathVis, vector<int> adj[]){
        vis[v] = true;
        pathVis[v] = true;
        for(int u: adj[v]){
            if(!vis[u]) {
                if(dfs(u, vis, pathVis, adj)) return true;
            } else if(pathVis[u]) return true;
        }
        pathVis[v] = false;
        return false;
    }

    bool isCyclic(int V, vector<int> adj[]) {
        vector<bool> vis(V,false);
        vector<bool> pathVis(V,false);
        
        //traverse all components(connected and disconnnected)
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(i, vis, pathVis, adj)) return true;
        }
        return false;
    }
};

// 3. TOPOSORT and Problems---------------------------------------
// actual Q14 - topological sort, directed graph
// time: O(E+V) - dfs and create adj 25, space:O(V+E) - stack vis, adj, 35
class Solution {
public:
    bool dfs(int v, vector<int>& vis, vector<int>& pathVis, stack<int>& s, vector<vector<int>>& adj){
        vis[v] = 1;
        pathVis[v] = 1;
        for(auto u:adj[v]){
            if(pathVis[u]) return false;
            if(!vis[u]) if(!dfs(u, vis, pathVis, s, adj)) return false;
        }
        
        s.push(v);
        pathVis[v] = 0;
        return true;
    }

    vector<int> findOrder(int V, vector<vector<int>>& edges) {
        vector<vector<int>>adj(V);
        for(int i = 0; i < edges.size(); i++){
            adj[edges[i][1]].push_back(edges[i][0]);
        }

        vector<int> vis(V,0);
        vector<int> pathVis(V,0);
        stack<int> s;

        for(int i = 0; i < V; i++){
            if(!vis[i]) if(!dfs(i, vis, pathVis, s, adj)) return vector<int>{};
        }

        vector<int> ans;
        while(!s.empty()){
            ans.push_back(s.top());
            s.pop();
        }
        
        return ans;
    }
};

// Q2 kahn's algorithm
// using bfs and checking prereq - same idea I had
// --------replacing queue with stack in the below code - time:30
// because bfs all the prereq courses are done first and so on, but in dfs do all traverse the paths - not ideal
// time: O(V+E)-bfs,adj 90%, space:O(V+E) 60% indeg, queue
class Solution {
public:
    vector<int> findOrder(int N, vector<vector<int>>& edges) {
        vector<vector<int>> adj(N);                   // {prerequisite-course : [list of next courses]}
        vector<int> ans, indegree(N);               // indegree[i] denotes number of prerequisite courses for ith course
        for(auto& edge : edges) 
            adj[edge[1]].push_back(edge[0]),            // forming adjacency list graph
            indegree[edge[0]]++;                     
        
        queue<int> q;
        for(int i = 0; i < N; i++)
            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites
        
        while(!q.empty()) {
            auto v = q.front(); q.pop();
            ans.push_back(v);                     // cur has no remaining pre courses, so we can take it now
            for(auto u : adj[v]) 
                if(--indegree[u] == 0)     // if there's a next course having 0 prequisite remaining,
                    q.push(u);             // then we can take it
        }

        if(size(ans) == N) return ans;              // ordering exists where all courses can be finished
        return {};                                      
    }
};

// Q3. cyle detection - directed graph
class Solution{
  public:
    bool isCyclic(int V, vector<int> adj[]) {
        vector<int> ans, indegree(V);               // indegree[i] denotes number of prerequisite courses for ith course
        for(int v = 0; v < V; v++){
            for(int u : adj[v]) indegree[u]++;
        }
        
        queue<int> q;
        for(int i = 0; i < V; i++)
            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites
        
        while(!q.empty()) {
            auto v = q.front(); q.pop();
            ans.push_back(v);                     // cur has no remaining pre courses, so we can take it now
            for(auto u : adj[v]) 
                if(--indegree[u] == 0)     // if there's a next course having 0 prequisite remaining,
                    q.push(u);             // then we can take it
        }

        if(ans.size() == V) return 0;              // ordering exists where all courses can be finished
        return 1;      
    }
};

// Q4, Q5 - course shecule same as Q2 ; 50, 70

// Q6 - find safe vertices - a vertex is safe if all paths starting from it end at a terminal (a vertex with no outgoing edges)
// have a safe arr which tracks safe nodes (1=safe, 0=not vis or not safe) so in dfs check for
// 1. (vis and !safe) => not safe => return false and 2. (!safe) => not known => if(!dfs(u)) => not safe and 3. if not above - it is safe => only after checking all neighbours and paths, we can decide if it is safe or not
// time: O(V+E) 85, space: O(V+E) 80 - bc dfs
class Solution {
public:
    bool dfs(int v, vector<bool>& safe, vector<bool>& vis, vector<bool>& pathVis, vector<vector<int>>& graph){
        vis[v] = true; pathVis[v] = true;
        for(int u : graph[v]){
            if(safe[u] == 0 && vis[u]) return false;
            else if(safe[u] == 0){
                if(pathVis[u]) return false;
                if(!dfs(u, safe, vis, pathVis, graph)) {safe[u] = 0; return false;} 
            }
        }
        safe[v] = 1;
        pathVis[v] = false;
        return true;
    }

    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int V = graph.size();
        vector<bool> vis(V,false);
        vector<bool> pathVis(V,false);
        vector<bool> safe(V,0);
        vector<int> ans;

        for(int i = 0; i < V; i++){
            if(graph[i].size() == 0) {safe[i] = true;}
        }

        for(int i = 0; i < V; i++){
            if(!vis[i]) dfs(i, safe, vis, pathVis, graph);
            if(safe[i])ans.push_back(i);
        }
        
        return ans;
    }
};

// 4.Shortest path problems --------------------------------------------
// Q1. shortest prom from a ver to all other vertices- using bfs
class Solution{
  public:
    vector<int> shortestPath(vector<vector<int>>& edges, int n,int m, int src){
        vector<vector<int>>adj(n);
        for(int i = 0; i < m; i++){
            adj[edges[i][0]].push_back(edges[i][1]);
            adj[edges[i][1]].push_back(edges[i][0]);
        }
        
        vector<int>dis(n,-1);
        queue<int> q;
        
        q.push(src);
        dis[src]= 0;
        
        while(!q.empty()){
            int v=q.front(); q.pop();
            
            for(int u: adj[v]){
                if(dis[u] == -1){
                    q.push(u);
                    dis[u] = dis[v]+1;
                }
            }
        }
        return dis;
    }
};

// shortest path for a DAG with weights ------> acyclic
class Solution{
     vector<int> shortestPath(int n,int m, vector<vector<int>>& edges){
        vector<vector<pair<int,int>>>adj(n);
        for(int i = 0; i < m; i++){
            adj[edges[i][0]].push_back(make_pair(edges[i][1],edges[i][2]));
        }
        
        vector<int>dis(n,-1);
        queue<int> q;
        
        q.push(0);
        dis[0]= 0;
        
        while(!q.empty()){
            int v=q.front(); q.pop();
            
            for(auto u: adj[v]){
                int d = dis[v]+ u.second;
                if(dis[u.first] == -1 || dis[u.first] > d){
                    q.push(u.first);        // it should not be if(dis[u]==-1)p.push(u.first), bcz when u is having another shorter path then its childen night have a shorter path as well
                    dis[u.first] = d;       // in the prev q, the 1st path encountered is the shortest bcz all wts are 1 , duh its bfs
                }
            }
        }
        return dis;
    }
};

// another method using toposort
// why toposort- it ensures that all the u coming befind v in the are closed to src than v in graph - maintains a precedence order
// time:O(N+E) - like dfs - faster than other algos

class Solution{
          private:
  void toposort(int v, vector<vector<pair<int,int>>> &adj, 
  vector<int>& vis, stack<int>& st){
      vis[v] = 1;
      for(u : adj[v]){
          if(!vis[u.first]) toposort(u.first, adj, vis, st);
      }
      
      st.push(v);
  }
  
  public:
     vector<int> shortestPath(int n,int m, vector<vector<int>>& edges){
        vector<vector<pair<int,int>>>adj(n);
        for(int i = 0; i < m; i++){
            adj[edges[i][0]].push_back(make_pair(edges[i][1],edges[i][2]));
        }
        
        vector<int>vis(n,0);
        stack<int> st;
        for(int i = 0; i < n; i++){
            if(!vis[i])toposort(i, adj, vis, st);
        }
        
        vector<int>dis(n,1e9);
        dis[0] = 0;
        while(!st.empty()){
            int v = st.top(); st.pop();
            
            for(auto u: adj[v]){
                int d = u.second + dis[v];
                if(d < dis[u.first]) dis[u.first] = d; 
            }
        }
        for(int i = 0; i < n; i++){
            if(dis[i] == 1e9)dis[i] = -1;
        }
        return dis;
    }
};

// shortest path from a node to all vertices, undirected, weighted graph
// worked with the above bfs code - time:0.11s
class Solution{
	public:
	//Function to find the shortest distance of all the vertices
    //from the source vertex S.
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S){     //vector of vector of list (like 3d arr instead of 2d arr of pair)
        vector<int>dis(V,-1);
        queue<int> q;
        
        q.push(S);
        dis[S]= 0;
        
        while(!q.empty()){
            int v=q.front(); q.pop();
            
            for(auto u: adj[v]){
                int d = dis[v]+ u[1];
                if(dis[u[0]] == -1 || dis[u[0]] > d){
                    q.push(u[0]);        // it should not be if(dis[u]==-1)p.push(u.first), bcz when u is having another shorter path then its childen night have a shorter path as well
                    dis[u[0]] = d;       // in the prev q, the 1st path encountered is the shortest bcz all wts are 1 , duh its bfs
                }
            }
        }
        return dis;
    }
};

// Dijkstra's Algorith
// can not use if graph has -ve weights : infinite loop, bcz path wt gets smaller and smaller in that path (undirected graph loops)
// using priority queue - O(ElogV) time-0.09s faster than above bfs O(V+E)
// bfs explores all paths, because priority queue stored by priority, it deals with closer vertices first and can catch closer paths quickly, whearase set can replace even if a longer than is present in the data structure and pq would still have the longer path but bcz the vertex is already explored from shorted path, we need not explore it twice with the longer path in pq
class Solution{
    public:
	//Function to find the shortest distance of all the vertices
    //from the source vertex S.
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S){
        vector<int>dis(V,1e9);
        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> >pq;           // min heap - priority 1st for dist then node num
        
        dis[S]= 0;
        pq.push({dis[S],S});
        
        while(!pq.empty()){
            int d = pq.top().first;
            int v = pq.top().second;
            pq.pop();
            
            for(auto it: adj[v]){
                int wt = it[1];
                int u = it[0];
                
                if(wt+d < dis[u]){
                    dis[u] = wt+d;
                    pq.push({dis[u], u});
                }
            }
        }
        return dis;
    }
};

// Dijkstra algorithm - using Set - has an erase option O(logn), without it, there might be iterations in future
// time : faster than pq , 0.08s
class Solution{
    	public:
	//Function to find the shortest distance of all the vertices
    //from the source vertex S.
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S){
        vector<int>dis(V,1e9);
        set<pair<int,int>>st;

        dis[S]= 0;
        st.insert({dis[S],S});
        
        while(!st.empty()){
            auto it = *(st.begin());
            int d = it.first;
            int v = it.second;
            st.erase(it);
            
            for(auto it: adj[v]){
                int u = it[0];
                int wt = it[1];
                
                if(wt+d < dis[u]){
                    // erase if there is another path (longer) existing
                    if(dis[u] != 1e9) st.erase({dis[u],u});
                
                    dis[u] = wt+d;
                    st.insert({dis[u], u});
                }
            }
        }
        return dis;
    }
};

// Q4. Shortest path in binary matrix
// src - (0,0), dest - (n-1,m-1) and can only travel through the cells with 0 and not with 1.
// simple bfs - time:O(V+E)=>O(n*m) 20, space:O(v)=>O(n*m) queue 10%
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        queue<pair<int,int>>q;
        int n = grid.size(), m = grid[0].size();
        if(grid[0][0] != 0 || grid[n-1][m-1] != 0)return -1;
        q.push({0,0});
        grid[0][0] = 1;

        while(!q.empty()){
            auto v = q.front();
            q.pop();
            int r = v.first, c = v.second;
            vector<int>dr = {-1,-1,-1, 0, 0, 1, 1, 1};
            vector<int>dc = {-1, 0, 1,-1, 1,-1, 0, 1};

            for(int i = 0; i < 8; i++){
                int nr = r+dr[i], nc = c+dc[i];
                if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] == 0){
                    q.push({nr,nc});
                    grid[nr][nc] = grid[r][c] + 1;
                }
            }
        }

        if(grid[n-1][m-1] == 0 && (n-1 != 0 && m != 0))return -1;
        return grid[n-1][m-1];
    }
};

// using Dijkstra's Algo
// time:O(ElogV) 16%, space:O(n*m) 8%
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        if(n == 1 && m == 1 && grid[0][0] == 0)return 1;
        queue<pair<int,pair<int,int>>>q;
        vector<vector<int>> dis(n, vector<int>(m,1e9));

        if(grid[0][0] != 0 || grid[n-1][m-1] != 0)return -1;
        dis[0][0] = 1;
        q.push({dis[0][0],{0,0}});

        while(!q.empty()){
            auto v = q.front();
            q.pop();
            auto d = v.first;
            int r = v.second.first, c = v.second.second;
            vector<int>dr = {-1,-1,-1, 0, 0, 1, 1, 1};
            vector<int>dc = {-1, 0, 1,-1, 1,-1, 0, 1};

            for(int i = 0; i < 8; i++){
                int nr = r+dr[i], nc = c+dc[i];
                if(nr >= 0 && nr < n && nc >= 0 && nc < m && 
                grid[nr][nc] == 0 && dis[nr][nc] > d+1){
                    dis[nr][nc] = dis[r][c] + 1;
                    q.push({dis[nr][nc],{nr,nc}});
                    if(nr == n-1 && nc == m-1)return 1+d;
                }
            }
        }

        if(grid[n-1][m-1] == 0 && (n-1 != 0 && m != 0))return -1;
        // return grid[n-1][m-1];
        return -1;
    }
};