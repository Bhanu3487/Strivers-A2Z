#include <iostream>
using namespace std;

// AM - space complexity issues - use AL
// dfs - using stack data structure(same as bfs) and using resursion (can also do backtracing)
// dfs - the traversal order is seen when poping, in bfs the traversal order is seen when pushing q5 and q6 in learning
// dfs is slower than bfs (bfs gets into the queue in that order and gets excecuted neatly) - don't write a separate bfs function (auxilary stack space) whearas for dfs its better?

// 4. shortest path from a node to all points
// undirected unit weight - simple bfs
// undirected weighted - dijkstras          // directed weighted acylcic - simple bfs/ toposort with bfs

// learning
// Q1 - num of graphs possible with n vertices - ans: pow(2,(n*(n-1))/2) - check using adj matrix

// Q2,3 - convert edges to al edges -> am -> al - tle 
vector<vector<int>> printGraph(int V, vector<pair<int,int>>edges) {
    vector<vector<int>> am(V, vector<int>(V,0));
    vector<vector<int>> al(V);
    
    for(auto edge: edges){
        am[edge.first][edge.second] = 1;
        am[edge.second][edge.first] = 1;
    }
    
    for(int i = 0; i < V; i++){
        for(int j = 0; j < V; j++){
            if(am[i][j]) al[i].push_back(j);
        }
    }
    return al;
}

// better method - edges to al
vector<vector<int>> printGraph(int V, vector<pair<int,int>>edges) {
    vector<vector<int>> al(V);
    
    for(auto edge: edges){
        al[edge.first].push_back(edge.second);
        al[edge.second].push_back(edge.first);
    }

    return al;
}

// Q4 - connected components (in a disconnected graphs)
// to traversal in a disconnected graph - keep track of visited vertices.
for(auto v: V){
    if(!visited[v]) traversal(v)        //visited is and arr and traversal is a func 
}

// Q5 Function to return Breadth First Traversal of given graph.
vector<int> bfsOfGraph(int V, vector<int> adj[]) {
    queue<int> q;
    vector<bool> visited(V,false);
    vector<int> bfs;
    
    q.push(0);
    visited[0] = true;

    while(!q.empty()){
        int v = q.front();
        q.pop();
        bfs.push_back(v);
    
        for(int i: adj[v]){
            if(!visited[i]) {
                q.push(i);
                visited[i] = true;
            }
        }
    }
    
    return bfs;
}

// Q6 Function to return a list containing the DFS traversal of the graph.
vector<int> dfsOfGraph(int V, vector<int> adj[]) {
    vector<int> dfs;
    vector<int> visited(V, false);
    stack<int> st;
    
    st.push(0);
    
    while(!st.empty()){
        int v = st.top();
        st.pop();
        if(!visited[v]) {
            dfs.push_back(v);
            visited[v] = true;
        }
        
        // bcz we need to traverse the paths in a order from left to right
        for(int i = adj[v].size()-1; i >= 0; i--){
            if(!visited[adj[v][i]]){
                st.push(adj[v][i]);
            }
        }
    }
    return dfs;
}

// 2. traversal---------------------------------------------
// Q1 - num of connected componets

// dfs time: O(V+2E)22, space:O() 60
class Solution {
public:
    int findCircleNum(vector<vector<int>>& edges) {
        int n = edges.size();
        stack<int> s;
        vector<bool> visited(n, false);
        int ans = 0;

        for(int i = 0; i < n; i++){
            if(!visited[i]){
                s.push(i);
                visited[i] = true;
                ans++;
            }

            while(!s.empty()){
                int v = s.top();s.pop();
                
                for(int u = 0; u < n; u++){
                    if(edges[v][u] == 1 && visited[u] == false){
                        s.push(u);
                        visited[u] = true;
                    }
                }
            }
        }

        return ans;
    }
};

// time:O(n^2)95%, space:O(n)58%
class Solution {
public:
    int check(vector<bool>& visited){
        for(int i = 0; i < visited.size(); i++){
            if(visited[i] == false) return i;
        }
        return -1;
    }

    int findCircleNum(vector<vector<int>>& edges) {
        int n = edges.size();
        queue<int> q;
        vector<bool> visited(n, false);
        int ans = 0;

        int c = check(visited);
        while(c != -1){
            q.push(c);
            visited[c] = true;
            ans++;
            
            while(!q.empty()){
                int v = q.front();
                q.pop();
                
                for(int u = 0; u < n; u++){
                    if(edges[v][u] == 1 && visited[u] == false){
                        q.push(u);
                        visited[u] = true;
                    }
                }
            }
            
            c = check(visited);
        }
        return ans;
    }
};

// time:O(n^2)60%, space:O(n)5%
class Solution {
public:
    void bfsOfGraph(int v, vector<vector<int>> adj, vector<bool>& visited) {        
        queue<int> q;
        q.push(v);
        visited[v] = true;

        while(!q.empty()){
            int v = q.front();
            q.pop();
        
            for(int u = 0; u < adj.size(); u++){
                if(!visited[u] && adj[v][u] == 1) {
                    q.push(u);
                    visited[u] = true;
                }
            }
        }
        return;
    }

    int findCircleNum(vector<vector<int>>& edges) {
        vector<bool> visited(edges.size(),false);
        int ans = 0;
        for(int i = 0; i < edges.size(); i++){
            if(visited[i] == false) {bfsOfGraph(i, edges, visited); ans++;}
        }
        return ans;
    }
};

// Q3 - rotten oranges - the fresh tomatoes around rotten tomatoes get rotten, in how much time will all tomatoes rot
// 1.30, time:O(n*m) 100, space:O(n*m) 9
class Solution {
public:
    void bfs(vector<vector<int>>& grid, vector<bool>& vis, vector<int>& dis, vector<int>& rot){
        int n = grid.size();
        int m = grid[0].size();
        queue<int> q;

        for(int r: rot) {q.push(r); vis[r] = true;}

        while(!q.empty()){
            int v = q.front(); q.pop();
            int r = v/m, c = v%m;

            cout<<v << " " <<r<<" "<<c;
            
            if(r > 0 && vis[m*(r-1)+c] == false){
                if(grid[r-1][c] == 0 || grid[r-1][c] == 2) vis[m*(r-1)+c] = true;
                else{
                    q.push(m*(r-1)+c);
                    vis[m*(r-1)+c] = true;
                    dis[m*(r-1)+c] = 1 + dis[v];
                }
            }

            if(r != n-1 && vis[m*(r+1)+c] == false){
                if(grid[r+1][c] == 0 || grid[r+1][c] == 2) vis[m*(r+1)+c] = true;
                else{
                    q.push(m*(r+1)+c);
                    vis[m*(r+1)+c] = true;
                    dis[m*(r+1)+c] = 1 + dis[v];
                }
            }  

            if(c != m-1 && vis[m*r+(c+1)] == false){
                if(grid[r][c+1] == 0 || grid[r][c+1] == 2) vis[m*r+(c+1)] = true;
                else{
                    q.push(m*r+(c+1));
                    vis[m*r+(c+1)] = true;
                    dis[m*r+(c+1)] = 1 + dis[v];
                }
            }   

            if(c > 0 && vis[m*r+(c-1)] == false){
                if(grid[r][c-1] == 0 || grid[r][c-1] == 2) vis[m*r+(c-1)] = true;
                else{
                    q.push(m*r+(c-1));
                    vis[m*r+(c-1)] = true;
                    dis[m*r+(c-1)] = 1 + dis[v];
                }
            }         
        }
    }

    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<bool> vis(n*m, false);
        vector<int> dis(n*m, 0);

        int flag = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 1) {flag = 1; break;}
            }
        }
        if(flag == 0)return 0;

        vector<int> rot;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 2) rot.push_back(m*i+j);
            }
        }
        if(rot.size() == 0)return -1;
        bfs(grid, vis, dis, rot);

        int d = INT_MIN;
        for(int i = 0; i < n*m; i++){
            if(d < dis[i]) d = dis[i];
            if(vis[i] == false && grid[i/m][i%m] == 1)return -1;
        }

        return d;
    }
};

// 85, 15
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> dis(n, vector<int>(m,0));
        queue<pair<int,int>> q;

        int fresh = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 2) q.push(make_pair(i,j)); 
                if(grid[i][j] == 1) fresh = 1;
            }
        }
        if(fresh == 0)return 0;
        if(q.empty())return -1;

        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,-1,0,1};

        while(!q.empty()){
            int r = q.front().first;
            int c = q.front().second;
            q.pop();

            for (int i = 0; i < 4; i++) {
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] == 1) {
                    q.push(make_pair(nr, nc));
                    grid[nr][nc] = 2;  
                    dis[nr][nc] = dis[r][c] + 1;
                }
            }
        }
        
        int d = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 1) return -1;
                d = max(d, dis[i][j]);
            }
        }

        return d;
    }
};

// Q4 flood fill, hiven source and req clr and start clr - from source any pixel with start clr gets converted to req clr and ro return the final clrs
// 45,60
class Solution {
private:
    void dfs(int row, int col, vector<vector<int>>& ans,vector<vector<int>>& image,int iniColor, int newColor, int delRow[], int delCol[]){
        if(ans[row][col] != newColor){      // mem % inc by 15 when added this line
            ans[row][col] = newColor;
            for(int i = 0; i < 4; i++){
                int nrow = row + delRow[i];
                int ncol = col + delCol[i];
                if(nrow >= 0 && nrow < image.size() && ncol >= 0 && ncol < image[0].size() && image[nrow][ncol] == iniColor && ans[nrow][ncol] != newColor){
                    dfs(nrow, ncol, ans, image, iniColor, newColor, delRow, delCol);
                }
            }
        }
    }

public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int iniColor = image[sr][sc];
        vector<vector<int>> ans = image;
        int delRow[] = {-1, 0 ,1, 0};
        int delCol[] = {0, 1, 0, -1};
        dfs(sr, sc, ans, image, iniColor, color, delRow, delCol);
        return ans;
    }
};

// Q5 cycle detection - dfs - can also use bfs - queue
class Solution{
  public:
    int dfs(int V, vector<int> adj[], vector<bool>& vis, int r){
        stack<int> st;
        st.push(r);
        vector<bool> vis2(V, false);
        vector<int> par(V, -1);
        vis[r] = true; vis2[r] = true;par[r] = r;
        
        while(!st.empty()){
            int v = st.top(); st.pop();
            
            for(int u: adj[v]){
                if(vis2[u] && u!=v && u != par[v]) return 1;
                if(!vis[u]){
                    st.push(u);
                    vis[u] = true; vis2[u] = true;
                    par[u] = v;
                }
            }
        }
        return 0;
    }
    
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool> vis(V, false);
        
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(V, adj, vis, i))return 1;
        }
        return 0;
    }
};

// can be done with pathVis - i think this is better with just 1 var par
class Solution{
 private:
    bool dfs(int v, int par, vector<bool>&vis, vector<int> adj[]){
        vis[v] = true;
        for(auto u: adj[v]){
            if(!vis[u]) {if(dfs(u, v, vis, adj)) return true;}
            else if(u != par) return true;
        }
        return false;
    }
    
  public:
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool> vis(V, false);
        
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(i, -1, vis, adj))return true;
        }
        return false;
    }
};

// Cycle detection - bfs - rep stack with queue in dfs
// time: O(V + 2E) (2E = sum(degree) = sum(adj edges) in undir graph)
// queue :O(V) - queue and vis and par
class Solution{
public:
    int dfs(int V, vector<int> adj[], vector<bool>& vis, int r){
        queue<int> q;
        q.push(r);
        vector<bool> vis2(V, false);
        vector<int> par(V, -1);
        vis[r] = true; vis2[r] = true;par[r] = r;
        
        while(!q.empty()){
            int v = q.front(); q.pop();
            
            for(int u: adj[v]){
                if(vis2[u] && u!=v && u != par[v]) return 1;
                if(!vis[u]){
                    q.push(u);
                    vis[u] = true; vis2[u] = true;
                    par[u] = v;
                }
            }
        }
        return 0;
    }
    
    bool isCycle(int V, vector<int> adj[]) {
        vector<bool> vis(V, false);
        
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(V, adj, vis, i))return 1;
        }
        return 0;
    }
};


// Q8 - surrounding region, find all the connected regions in contect with the edges, keep these unaffected, and convert the remaining regions
// time :O(V+2E => (n*m) + 2*n*m) dfs + O(n*m) - 33, space:O()ASS - 7
class Solution {
public:
    void dfs(vector<vector<char>>& board, int r, int c){
        if(board[r][c] == 'x' || board[r][c] == 'X')return;
        int n = board.size();
        int m = board[0].size();
        
        board[r][c] = 'x';
        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,-1,0,1};

        for(int i = 0; i < 4; i++){
            int nr = r+dr[i], nc = c+dc[i];
            if(nr < n && nc < m && nr >= 0 && nc >= 0) {
                dfs(board, nr, nc);
            }
        }
        return;
    }

    void solve(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();
        
        for(int i = 0; i < n; i++){
            if(board[i][0] == 'O') dfs(board, i, 0);
            if(board[i][m-1] == 'O') dfs(board, i, m-1);
        }

        for(int i = 1; i < m-1; i++){
            if(board[0][i] == 'O') dfs(board, 0, i);
            if(board[n-1][i] == 'O') dfs(board, n-1, i);
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(board[i][j] == 'O')board[i][j] = 'X';
                if(board[i][j] == 'x')board[i][j] = 'O';
            }
        }

        return;
    }
};

// Q9 - flood fill - same as above q
// time:5, space:5
class Solution {
public:
    void dfs(vector<vector<int>>& board, int r, int c){
        if(board[r][c] == 0)return;
        int n = board.size();
        int m = board[0].size();
        
        board[r][c] = 0;
        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,-1,0,1};

        for(int i = 0; i < 4; i++){
            int nr = r+dr[i], nc = c+dc[i];
            if(nr < n && nc < m && nr >= 0 && nc >= 0) {
                dfs(board, nr, nc);
            }
        }
        return;
    }

    int numEnclaves(vector<vector<int>>& board) {
        int n = board.size();
        int m = board[0].size();
        
        for(int i = 0; i < n; i++){
            if(board[i][0] == 1) dfs(board, i, 0);
            if(board[i][m-1] == 1) dfs(board, i, m-1);
        }

        for(int i = 1; i < m-1; i++){
            if(board[0][i] == 1) dfs(board, 0, i);
            if(board[n-1][i] == 1) dfs(board, n-1, i);
        }

        int ans = 0;
        for(int i = 1; i < n-1; i++){
            for(int j = 1; j < m-1; j++){
                if(board[i][j] == 1) ans++;
            }
        }

        return ans;
    }
};

// same code as above but 40, 60
class Solution {
public:
    void dfs(vector<vector<int>>& grid,int i,int j,int m,int n){
        if(i<0 || i >=m || j<0 || j>=n || grid[i][j] == 0 || grid[i][j] == 2) return;
        grid[i][j] = 2;
        int ai[] = {0,1,0,-1};
        int aj[] = {1,0,-1,0};

        for(int k=0;k<4;k++){
            dfs(grid,i+ai[k],j+aj[k],m,n);
        }
    }
    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        for(int i=0;i<m;i++){
            dfs(grid,i,0,m,n);
            dfs(grid,i,n-1,m,n);
        }
        for(int i=0;i<n;i++){
            dfs(grid,0,i,m,n);
            dfs(grid,m-1,i,m,n);
        }

        int count = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1) count++;
            }
        }

        return count;
    }
};

// Q13
// time:O(V+2E) 85, space:O(V) 20
class Solution {
public:
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> cls(n,-1);

        for(int i = 0; i < n; i++){
            if(cls[i] == -1){
                queue<int> q;
                cls[i] = i;
                q.push(i);

                while(!q.empty()){
                    int v = q.front(); q.pop();

                    for(int u: graph[v]){
                        if(cls[u] == cls[v]) return false;
                        else if(cls[u] == -1) {cls[u] = cls[v]^1; q.push(u);}
                    }
                }
            }
        }
        
        return true;
    }
};

// Q14- cycle detection in directed graph - using dfs (using bfs in toposort)
class Solution {
public:
    bool dfs(int v, vector<bool>& vis, vector<bool>& pathVis, vector<int> adj[]){
        vis[v] = true;
        pathVis[v] = true;
        for(int u: adj[v]){
            if(!vis[u]) {
                if(dfs(u, vis, pathVis, adj)) return true;
            } else if(pathVis[u]) return true;
        }
        pathVis[v] = false;
        return false;
    }

    bool isCyclic(int V, vector<int> adj[]) {
        vector<bool> vis(V,false);
        vector<bool> pathVis(V,false);
        
        //traverse all components(connected and disconnnected)
        for(int i = 0; i < V; i++){
            if(!vis[i]) if(dfs(i, vis, pathVis, adj)) return true;
        }
        return false;
    }
};

// 3. TOPOSORT and Problems---------------------------------------
// actual Q14 - topological sort, directed graph
// time: O(E+V) - dfs and create adj 25, space:O(V+E) - stack vis, adj, 35
class Solution {
public:
    bool dfs(int v, vector<int>& vis, vector<int>& pathVis, stack<int>& s, vector<vector<int>>& adj){
        vis[v] = 1;
        pathVis[v] = 1;
        for(auto u:adj[v]){
            if(pathVis[u]) return false;
            if(!vis[u]) if(!dfs(u, vis, pathVis, s, adj)) return false;
        }
        
        s.push(v);
        pathVis[v] = 0;
        return true;
    }

    vector<int> findOrder(int V, vector<vector<int>>& edges) {
        vector<vector<int>>adj(V);
        for(int i = 0; i < edges.size(); i++){
            adj[edges[i][1]].push_back(edges[i][0]);
        }

        vector<int> vis(V,0);
        vector<int> pathVis(V,0);
        stack<int> s;

        for(int i = 0; i < V; i++){
            if(!vis[i]) if(!dfs(i, vis, pathVis, s, adj)) return vector<int>{};
        }

        vector<int> ans;
        while(!s.empty()){
            ans.push_back(s.top());
            s.pop();
        }
        
        return ans;
    }
};

// Q2 kahn's algorithm
// using bfs and checking prereq - same idea I had
// --------replacing queue with stack in the below code - time:30
// because bfs all the prereq courses are done first and so on, but in dfs do all traverse the paths - not ideal
// time: O(V+E)-bfs,adj 90%, space:O(V+E) 60% indeg, queue
class Solution {
public:
    vector<int> findOrder(int N, vector<vector<int>>& edges) {
        vector<vector<int>> adj(N);                   // {prerequisite-course : [list of next courses]}
        vector<int> ans, indegree(N);               // indegree[i] denotes number of prerequisite courses for ith course
        for(auto& edge : edges) 
            adj[edge[1]].push_back(edge[0]),            // forming adjacency list graph
            indegree[edge[0]]++;                     
        
        queue<int> q;
        for(int i = 0; i < N; i++)
            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites
        
        while(!q.empty()) {
            auto v = q.front(); q.pop();
            ans.push_back(v);                     // cur has no remaining pre courses, so we can take it now
            for(auto u : adj[v]) 
                if(--indegree[u] == 0)     // if there's a next course having 0 prequisite remaining,
                    q.push(u);             // then we can take it
        }

        if(size(ans) == N) return ans;              // ordering exists where all courses can be finished
        return {};                                      
    }
};

// Q3. cyle detection - directed graph
class Solution{
  public:
    bool isCyclic(int V, vector<int> adj[]) {
        vector<int> ans, indegree(V);               // indegree[i] denotes number of prerequisite courses for ith course
        for(int v = 0; v < V; v++){
            for(int u : adj[v]) indegree[u]++;
        }
        
        queue<int> q;
        for(int i = 0; i < V; i++)
            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites
        
        while(!q.empty()) {
            auto v = q.front(); q.pop();
            ans.push_back(v);                     // cur has no remaining pre courses, so we can take it now
            for(auto u : adj[v]) 
                if(--indegree[u] == 0)     // if there's a next course having 0 prequisite remaining,
                    q.push(u);             // then we can take it
        }

        if(ans.size() == V) return 0;              // ordering exists where all courses can be finished
        return 1;      
    }
};

// Q4, Q5 - course shecule same as Q2 ; 50, 70

// Q6 - find safe vertices - a vertex is safe if all paths starting from it end at a terminal (a vertex with no outgoing edges)
// have a safe arr which tracks safe nodes (1=safe, 0=not vis or not safe) so in dfs check for
// 1. (vis and !safe) => not safe => return false and 2. (!safe) => not known => if(!dfs(u)) => not safe and 3. if not above - it is safe => only after checking all neighbours and paths, we can decide if it is safe or not
// time: O(V+E) 85, space: O(V+E) 80 - bc dfs
class Solution {
public:
    bool dfs(int v, vector<bool>& safe, vector<bool>& vis, vector<bool>& pathVis, vector<vector<int>>& graph){
        vis[v] = true; pathVis[v] = true;
        for(int u : graph[v]){
            if(safe[u] == 0 && vis[u]) return false;
            else if(safe[u] == 0){
                if(pathVis[u]) return false;
                if(!dfs(u, safe, vis, pathVis, graph)) {safe[u] = 0; return false;} 
            }
        }
        safe[v] = 1;
        pathVis[v] = false;
        return true;
    }

    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int V = graph.size();
        vector<bool> vis(V,false);
        vector<bool> pathVis(V,false);
        vector<bool> safe(V,0);
        vector<int> ans;

        for(int i = 0; i < V; i++){
            if(graph[i].size() == 0) {safe[i] = true;}
        }

        for(int i = 0; i < V; i++){
            if(!vis[i]) dfs(i, safe, vis, pathVis, graph);
            if(safe[i])ans.push_back(i);
        }
        
        return ans;
    }
};

// 4.Shortest path problems --------------------------------------------
// Q1. shortest prom from a ver to all other vertices- using bfs
class Solution{
  public:
    vector<int> shortestPath(vector<vector<int>>& edges, int n,int m, int src){
        vector<vector<int>>adj(n);
        for(int i = 0; i < m; i++){
            adj[edges[i][0]].push_back(edges[i][1]);
            adj[edges[i][1]].push_back(edges[i][0]);
        }
        
        vector<int>dis(n,-1);
        queue<int> q;
        
        q.push(src);
        dis[src]= 0;
        
        while(!q.empty()){
            int v=q.front(); q.pop();
            
            for(int u: adj[v]){
                if(dis[u] == -1){
                    q.push(u);
                    dis[u] = dis[v]+1;
                }
            }
        }
        return dis;
    }
};

// shortest path for a DAG with weights ------> acyclic
class Solution{
     vector<int> shortestPath(int n,int m, vector<vector<int>>& edges){
        vector<vector<pair<int,int>>>adj(n);
        for(int i = 0; i < m; i++){
            adj[edges[i][0]].push_back(make_pair(edges[i][1],edges[i][2]));
        }
        
        vector<int>dis(n,-1);
        queue<int> q;
        
        q.push(0);
        dis[0]= 0;
        
        while(!q.empty()){
            int v=q.front(); q.pop();
            
            for(auto u: adj[v]){
                int d = dis[v]+ u.second;
                if(dis[u.first] == -1 || dis[u.first] > d){
                    q.push(u.first);        // it should not be if(dis[u]==-1)p.push(u.first), bcz when u is having another shorter path then its childen night have a shorter path as well
                    dis[u.first] = d;       // in the prev q, the 1st path encountered is the shortest bcz all wts are 1 , duh its bfs
                }
            }
        }
        return dis;
    }
};

// another method using toposort
// why toposort- it ensures that all the u coming befind v in the are closed to src than v in graph - maintains a precedence order
// time:O(N+E) - like dfs - faster than other algos

class Solution{
          private:
  void toposort(int v, vector<vector<pair<int,int>>> &adj, 
  vector<int>& vis, stack<int>& st){
      vis[v] = 1;
      for(u : adj[v]){
          if(!vis[u.first]) toposort(u.first, adj, vis, st);
      }
      
      st.push(v);
  }
  
  public:
     vector<int> shortestPath(int n,int m, vector<vector<int>>& edges){
        vector<vector<pair<int,int>>>adj(n);
        for(int i = 0; i < m; i++){
            adj[edges[i][0]].push_back(make_pair(edges[i][1],edges[i][2]));
        }
        
        vector<int>vis(n,0);
        stack<int> st;
        for(int i = 0; i < n; i++){
            if(!vis[i])toposort(i, adj, vis, st);
        }
        
        vector<int>dis(n,1e9);
        dis[0] = 0;
        while(!st.empty()){
            int v = st.top(); st.pop();
            
            for(auto u: adj[v]){
                int d = u.second + dis[v];
                if(d < dis[u.first]) dis[u.first] = d; 
            }
        }
        for(int i = 0; i < n; i++){
            if(dis[i] == 1e9)dis[i] = -1;
        }
        return dis;
    }
};

// shortest path from a node to all vertices, undirected, weighted graph
// worked with the above bfs code - time:0.11s
class Solution{
	public:
	//Function to find the shortest distance of all the vertices
    //from the source vertex S.
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S){     //vector of vector of list (like 3d arr instead of 2d arr of pair)
        vector<int>dis(V,-1);
        queue<int> q;
        
        q.push(S);
        dis[S]= 0;
        
        while(!q.empty()){
            int v=q.front(); q.pop();
            
            for(auto u: adj[v]){
                int d = dis[v]+ u[1];
                if(dis[u[0]] == -1 || dis[u[0]] > d){
                    q.push(u[0]);        // it should not be if(dis[u]==-1)p.push(u.first), bcz when u is having another shorter path then its childen might have a shorter path as well
                    dis[u[0]] = d;       // in the prev q, the 1st path encountered is the shortest bcz all wts are 1 , duh its bfs
                }
            }
        }
        return dis;
    }
};

// Dijkstra's Algorith
// can not use if graph has -ve weights : infinite loop, bcz path wt gets smaller and smaller in that path (undirected graph loops)
// using priority queue - O(ElogV) time-0.09s faster than above bfs O(V+E)
// bfs explores all paths, because priority queue stored by priority, it deals with closer vertices first and can catch closer paths quickly, whearase set can replace even if a longer than is present in the data structure and pq would still have the longer path but bcz the vertex is already explored from shorted path, we need not explore it twice with the longer path in pq
class Solution{
    public:
	//Function to find the shortest distance of all the vertices
    //from the source vertex S.
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S){
        vector<int>dis(V,1e9);
        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> >pq;           // min heap - priority 1st for dist then node num
        
        dis[S]= 0;
        pq.push({dis[S],S});
        
        while(!pq.empty()){
            int d = pq.top().first;
            int v = pq.top().second;
            pq.pop();
            
            for(auto it: adj[v]){
                int wt = it[1];
                int u = it[0];
                
                if(wt+d < dis[u]){
                    dis[u] = wt+d;
                    pq.push({dis[u], u});
                }
            }
        }
        return dis;
    }
};

// Q4 .Dijkstra algorithm - using Set - has an erase option O(logn), without it, there might be iterations in future
// time : faster than pq , 0.08s
class Solution{
    	public:
	//Function to find the shortest distance of all the vertices
    //from the source vertex S.
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S){
        vector<int>dis(V,1e9);
        set<pair<int,int>>st;

        dis[S]= 0;
        st.insert({dis[S],S});
        
        while(!st.empty()){
            auto it = *(st.begin());
            int d = it.first;
            int v = it.second;
            st.erase(it);
            
            for(auto it: adj[v]){
                int u = it[0];
                int wt = it[1];
                
                if(wt+d < dis[u]){
                    // erase if there is another path (longer) existing
                    if(dis[u] != 1e9) st.erase({dis[u],u});
                
                    dis[u] = wt+d;
                    st.insert({dis[u], u});
                }
            }
        }
        return dis;
    }
};

// Q5. Shortest path in binary matrix
// src - (0,0), dest - (n-1,m-1) and can only travel through the cells with 0 and not with 1.
// simple bfs - time:O(V+E)=>O(n*m) 20, space:O(v)=>O(n*m) queue 10%
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        queue<pair<int,int>>q;
        int n = grid.size(), m = grid[0].size();
        if(grid[0][0] != 0 || grid[n-1][m-1] != 0)return -1;
        q.push({0,0});
        grid[0][0] = 1;

        while(!q.empty()){
            auto v = q.front();
            q.pop();
            int r = v.first, c = v.second;
            vector<int>dr = {-1,-1,-1, 0, 0, 1, 1, 1};
            vector<int>dc = {-1, 0, 1,-1, 1,-1, 0, 1};

            for(int i = 0; i < 8; i++){
                int nr = r+dr[i], nc = c+dc[i];
                if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] == 0){
                    q.push({nr,nc});
                    grid[nr][nc] = grid[r][c] + 1;
                }
            }
        }

        if(grid[n-1][m-1] == 0 && (n-1 != 0 && m != 0))return -1;
        return grid[n-1][m-1];
    }
};

// using Dijkstra's Algo
// time:O(ElogV) 16%, space:O(n*m) 8%
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        if(n == 1 && m == 1 && grid[0][0] == 0)return 1;
        queue<pair<int,pair<int,int>>>q;
        vector<vector<int>> dis(n, vector<int>(m,1e9));

        if(grid[0][0] != 0 || grid[n-1][m-1] != 0)return -1;
        dis[0][0] = 1;
        q.push({dis[0][0],{0,0}});

        while(!q.empty()){
            auto v = q.front();
            q.pop();
            auto d = v.first;
            int r = v.second.first, c = v.second.second;
            vector<int>dr = {-1,-1,-1, 0, 0, 1, 1, 1};
            vector<int>dc = {-1, 0, 1,-1, 1,-1, 0, 1};

            for(int i = 0; i < 8; i++){
                int nr = r+dr[i], nc = c+dc[i];
                if(nr >= 0 && nr < n && nc >= 0 && nc < m && 
                grid[nr][nc] == 0 && dis[nr][nc] > d+1){
                    dis[nr][nc] = dis[r][c] + 1;
                    q.push({dis[nr][nc],{nr,nc}});
                    if(nr == n-1 && nc == m-1)return 1+d;
                }
            }
        }

        if(grid[n-1][m-1] == 0 && (n-1 != 0 && m != 0))return -1;
        // return grid[n-1][m-1];
        return -1;
    }
};

// Q5

// Q6. Find the cost of shortest path from src to dst with atmost k vertices in the path
// dijkstra's algorithm but more priority to stops - observation - bcz stops inc by 1, by default they get pushed in order so we can use queue itself.
// time: O(ElogV - for dijkstra but since it is bfs => E) = O(E) = O(flights.size()) 92% , space:O(V+E) 20%
class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<pair<int,int>> adj[n];
        for(auto it: flights){
            adj[it[0]].push_back({ it[1],it[2] });
        }

        queue< vector<int>> q;
        q.push(vector<int>{0,src,0});
        vector<int> dis(n, 1e9);
        dis[src] = 0;

        while(!q.empty()){
            auto it = q.front(); q.pop();
            int stops = it[0];
            int v = it[1];
            int price = it[2];

            if(stops > k)continue;
            if(v != dst){
                for(auto iter: adj[v]){
                    int u = iter.first, wt = iter.second;
                    if(stops <= k && price+wt < dis[u]){
                        dis[u] = price+wt;
                        q.push(vector<int>{stops+1, u, price+wt});
                    }
                }
            }
        }

        if(dis[dst] == 1e9) return -1;
        return dis[dst];
    }
};

// Q7 - dijkstra direct, with pair<dis,node> in  pq
// time:O(ElogV) - 96%, space:O(E) 63%
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<vector<pair<int,int>>> adj(n+1);
        for(int u = 0; u < times.size(); u++){ 
            adj[times[u][0]].push_back({times[u][2],times[u][1]});
        }

        vector<int> dis(n+1,1e9);
        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;
        pq.push({0,k});
        dis[k] = 0;

        while(!pq.empty()){
            auto it = pq.top(); pq.pop();
            int v = it.second;
            int time = it.first;

            for(auto i: adj[v]){
                int u = i.second;
                int wt = i.first;
                if(time+wt < dis[u]){
                    dis[u] = time+wt;
                    pq.push({dis[u],u});
                }
            }
        }

        int ans = -1;
        for(int i = 1; i < n+1; i++){
            if(dis[i] == 1e9)return -1;
            ans = max(ans, dis[i]);
        }
        return ans;
    }
};

// Q8 - num of shortest paths to reach n-1 from 0
// imp - remember if an edge exists btw a node v to node n-1 and is included in 2 shortest paths - then it is counted as 2 not 1 - bcz we are counting paths
// dijksttra's algo - tle with pq, prob with set - it converges any (d,n-1) present in set to 1 -> losing portential paths 

class Solution {
public:
    int countPaths(int n, vector<vector<int>>& roads) {
        vector<vector<pair<int,int>>> adj(n);
        for(int u = 0; u < roads.size(); u++){
            adj[roads[u][0]].push_back({roads[u][2],roads[u][1]});
            adj[roads[u][1]].push_back({roads[u][2],roads[u][0]});
        }

        vector<int>dis(n,1e9);
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;
        pq.push({0, 0});
        dis[0]=0;

        int m = 1e9, f = 0;
        while(!pq.empty()){
            auto it = pq.top(); pq.pop();
            int d = it.first;
            int v = it.second;

            if(v == n-1){
                if(d < m){m = d; f = 1;}
                else if(d == m){ f+=1; f = f % (1000000007); 
                }
            }
            for(auto i: adj[v]){
                int wt = i.first;
                int u = i.second;
                if(d+wt <= dis[u]){
                    dis[u] = d+wt;
                    pq.push({dis[u],u});
                }
            }
        }
        return f;
    }
};

// it passed but had an another prob that the shortest path cant fit in int
class Solution {
public:
    int countPaths(int n, vector<vector<int>>& roads) {
        vector<vector<pair<int,int>>> adj(n);
        for(int u = 0; u < roads.size(); u++){
            adj[roads[u][0]].push_back({roads[u][2],roads[u][1]});
            adj[roads[u][1]].push_back({roads[u][2],roads[u][0]});
        }

        vector<int>dis(n,1e9+1);
        vector<int>ways(n,0);
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;
        pq.push({0, 0});
        dis[0]=0;
        ways[0] = 1;

        int m = 1e9, f = 0;
        while(!pq.empty()){
            auto it = pq.top(); pq.pop();
            int d = it.first;
            int v = it.second;

            for(auto i: adj[v]){
                int wt = i.first;
                int u = i.second;
                if(d > INT_MAX - wt)d = INT_MAX;
                if(d < dis[u]-wt){
                    dis[u] = d+wt;
                    ways[u] = ways[v];
                    pq.push({dis[u],u});
                }
                else if(d == dis[u]-wt){
                    ways[u] = (ways[u]+ways[v])%1000000007;
                }
            }
        }
        for(int i = 0; i < n; i++) cout<<dis[i]<<" ";
        return ways[n-1];
    }
};

// Q9. given a num start and num end and an arr of int which can be multiplied with start and mod with 1e5 to get a new start. How many of such opr need to be done to reach from start to end
// nodes = 0 to 9999, each node has an indegree = 1 and outdegree = arr.size(), root has 0 indegree - tree
// no need to use priority queue since edges do not have ant wts mentioned and also staps increase in order - simple bfs
// using set in bfs to get rid of duplicates - tle
int minimumMultiplications(vector<int>& arr, int start, int end) {
        if(start == end)return 0;
        
        set<pair<int,int>>q;
        q.insert({0,start});

        set<int> s(arr.begin(), arr.end());
        if(s.find(1) != s.end()) s.erase(1);
        vector<int> a(s.begin(), s.end());

        while(!q.empty()){
            auto it = *(q.begin()); q.erase(it);
            int steps = it.first;
            int v = it.second;

            for(int i: a){
                int u = (v*i)%100000;
                if(u == end)return steps+1;
                q.insert({steps+1, u});
            }
        }
        return -1;
    }

// using simple bfs - but we only push the pair into queue when steps req to get there > dis
int minimumMultiplications(vector<int>& arr, int start, int end) {
    if(start == end)return 0;
    
    queue<pair<int,int>>q;
    q.push({0,start});
    vector<int>dis(100000,1e9);
    dis[start] = 0;

    while(!q.empty()){
        auto it = q.front(); q.pop();
        int steps = it.first;
        int v = it.second;

        for(int i: arr){
            int u = (v*i)%100000;
            if(steps+1 < dis[u]){
                dis[u] = steps+1;
                if(u == end) return steps+1;
                q.push({steps+1, u});
            }
        }
    }
    return -1;
}

// Find the shortest distance of all nodes from source - edge wts can be -ve => Bellan Ford Algo , dijkstra doesn't work
// using dfs(incoorect implementation) - only diff in dealing with -ve edge cycles - tle
class Solution{
  public:
    void dfs(int v, vector<int>& vis,  vector<int>& pathVis, vector<int>& dis, vector<vector<pair<int,int>>>& adj){
        vis[v] = 1; pathVis[v] = 1;
        for(auto it: adj[v]){
            int u = it.first, wt = it.second;
            
            if(pathVis[u] && dis[u] < 0){dis[u] = 1e9; return;}
            else if(!vis[u] || vis[u] && dis[u] > dis[v]+wt){
                dis[u] = dis[v]+wt;
                dfs(u, vis, pathVis, dis, adj);
            }
        }
        pathVis[v] = 0;
        return;
    }
    
    vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {
        vector<vector<pair<int,int>>> adj(V);
        for(int i = 0; i < edges.size(); i++){
            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});
        }
        
        vector<int> vis(V,0), pathVis(V,0), dis(V,1e8);
        dis[S] = 0;
        dfs(S, vis, pathVis, dis,adj);
        return vector<int>{};
        
    }
};

// dfs to detect -ve cycles
class Solution {
  public:
    void dfs(int v, vector<int>& vis,  vector<int>& pathVis, vector<int>& dis, vector<vector<pair<int,int>>>& adj, int& flag){
        if(flag == 1)return;
        vis[v] = 1; pathVis[v] = 1;
        for(auto it: adj[v]){
            int u = it.first, wt = it.second;
            
            if(pathVis[u] && dis[u] < 0){flag = 1; return;}
            else if(!vis[u] || vis[u] && dis[u] > dis[v]+wt){
                dis[u] = dis[v]+wt;
                dfs(u, vis, pathVis, dis, adj, flag);
            }
        }
        pathVis[v] = 0;
        return;
    }
    
    vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {
        vector<vector<pair<int,int>>> adj(V);
        for(int i = 0; i < edges.size(); i++){
            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});
        }
        
        vector<int> vis(V,0), pathVis(V,0), dis(V,1e8);
        dis[S] = 0;
        int flag = 0;
        dfs(S, vis, pathVis, dis, adj, flag);
        if(flag == 1)return vector<int>{-1};
        return dis;
    }
};

// Bellman ford - only for directed graphs (if given undirected - convert to directed)
// 1. relax all edges N-1 times. relax meaning iterate and check if dist[v] > dist[u] + wt and update
// why n-1, bcz any path has at max n-1 edges, so at max we need to do n-1 iters to obtain the shortest distance fron src to all nodes
// how to detect -ve cycle - if the dis dec by nth iter - node is on -ve cycle
class Solution {
  public:
    vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {
        vector<int>dis(V,1e8);
        dis[S]=0;
        
        for(int i = 0; i < V; i++){
            for(auto edge : edges){
                if(dis[edge[1]] > dis[edge[0]] + edge[2] && dis[edge[0]] != 1e8){
                    if(i == V-1) return vector<int>{-1};
                    else dis[edge[1]] = dis[edge[0]] + edge[2];
                }
            }
        }
        
        return dis;
    }
};  

// Floyd Warshall Algorithm
// shortest distance of all nodes from all nodes - using afj matrix where matrix[v][u] gives the shortest path from v to u
// using bellman ford - tle - or using dijkstra on all nodes - not aby better => V*ElogV => O(V^3)
class Solution {
  public:
    
    void bellman_ford(int v, vector<vector<int>>&matrix, vector<vector<int>>&edges){
        int V = matrix.size();

        for(int i = 0; i < V; i++){
            if(matrix[v][i] == -1) matrix[v][i] = INT_MAX;
        }

        for(int i = 0; i < V; i++){
            for(auto edge : edges){
                if(matrix[v][edge[0]] != INT_MAX && matrix[v][edge[1]] > matrix[v][edge[0]] + edge[2]){
                    matrix[v][edge[1]] = matrix[v][edge[0]] + edge[2];
                }
            }
            
        }
        return;
    }
    
	void shortest_distance(vector<vector<int>>&matrix){
	    int V = matrix.size();
	    vector<vector<int>>edges;
	    
	    for(int i =0; i < V; i++){
	        for(int j = 0; j < V; j++){
	            if(matrix[i][j] != -1 && matrix[i][j] != 0){
	                edges.push_back(vector<int>{i, j, matrix[i][j]});
	            }
	        }
	    }
	   
	   int i = 0;
	    for(int i = 0; i < V; i++){
	        bellman_ford(i, matrix, edges);
	    }
	    return;
	}
};

// Floyd Warshall Algorithm - nore like brute force- using precomputed values to find the shortest path, can detect -ve cycles also
// d[i][j] = min (d[i][k] + d[k][j])for all k
class Solution {
  public:
	void shortest_distance(vector<vector<int>>&matrix){
	    int V = matrix.size();
	    
	    for(int i = 0; i< V; i++){
	        for(int j = 0; j < V; j++){
	            if(i == j)matrix[i][j] = 0;
	            if(matrix[i][j] == -1)matrix[i][j] = 1e9;
	        }
	    }
	    
	    for(int k = 0; k < V; k++){
	        for(int i = 0; i< V; i++){
	            for(int j = 0; j < V; j++){
	                matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);
	            }
	        }
	    }
	    
	    for(int i = 0; i< V; i++){if(matrix[i][i] < 0)cout<<"negative cycle";}
	    
	    return;
	}
};

// Finding min reachable city
// the node which can reach the least num of cities with distance atmost = distanceThreshold. if 2 citites exist return the city with greater idx 
class Solution {
public:
    int findTheCity(int V, vector<vector<int>>& edges, int distanceThreshold) {
	    vector<vector<int>> matrix(V, vector<int>(V,1e9));
        for(auto edge: edges){
            matrix[edge[0]][edge[1]] = edge[2];
            matrix[edge[1]][edge[0]] = edge[2];
        }
        
        for(int i = 0; i< V; i++){matrix[i][i] = 0;}

        for (int k = 0; k < V; k++) {
            for (int i = 0; i < V; i++) {
                for (int j = i+1; j < V; j++) {
                    if (matrix[i][j] > matrix[i][k] + matrix[k][j]) {
                        matrix[i][j] = matrix[i][k] + matrix[k][j];
                        matrix[j][i] = matrix[j][k] + matrix[k][i];
                    }
                }
            }
        }

        int ans = 0;
        int minReachable = V;
        for (int i = 0; i < V; i++) {
            int reachable = 0;
            for (int j = 0; j < V; j++) {
                if (i != j && matrix[i][j] <= distanceThreshold) {
                    reachable++;
                }
            }
            if (reachable <= minReachable) {
                minReachable = reachable;
                ans = i;
            }
        }
        return ans;
    }
};

// MST, Disjoint sets ----------------------------------------------
// Q1
// Prim's Algorithm O(ElogV)
class Solution{
	public:
    int spanningTree(int V, vector<vector<int>> adj[])
    {
        priority_queue<pair<int,int>,  vector<pair<int,int>>, greater<pair<int,int>>>pq;
        vector<bool>vis(V,0);
        pq.push({0, 0});
        int sum = 0;
        
        while(!pq.empty()){
            auto it = pq.top(); pq.pop();
            int v = it.second;
            int wt = it.first;
            
            if(vis[v])continue;
            // add to mst : vis[true] here, not when adding to pq
            vis[v] = true;
            sum += wt;
            
            for(auto i: adj[v]){
                int u = i[0];
                int ewt = i[1];
                if(!vis[u]){
                    pq.push({ewt,u});
                }
            }
        }
        
        return sum;
    }
};

// Q3 disjoint set by rank
// finding the untimate parent and union: connecting the xth ult par with zth ult par
// generally union connects smaller set to larger set(rank) - then no change in rank and path com is simple, vice versa ranks upbate, travel time of all larger nodes inc

int find(int A[],int X){
    if(X == A[X]) return X;
    return A[X] = find(A, A[X]);        //path compression - O(4a)=<O(1)
}
void unionSet(int A[],int X,int Z){
	int p_x = find(A, X);
	int p_z = find(A, Z);
	
	if(p_x == p_z)return;
	else A[p_x] = p_z;
}

class DisjointSet{  //O(4a)=O(1)
    vector<int>rank, par, size;
public:
    DisjointSet(int n){
        rank.resize(n+1,0);
        par.resize(n+1);
        size.resize(n+1,0);
        for(int i = 0; i < n; i++){
            par[i] = i;
            size[i] = 1;
        }
    }

    int find(int par[],int X){
        if(X == par[X]) return X;
        return par[X] = find(par, par[X]);        //path compression - O(4a)=<O(1)
    }

        // union by rank
    void union_by_rank(int u, int v){
        int ulp_u = find(u);
        int ulp_v = find(v);

        if(ulp_u == ulp_v) return;
        if(rank[ulp_u] < rank[ulp_v]) par[ulp_u] = ulp_v;
        else if(rank[ulp_u] < rank[ulp_v]) par[ulp_v] = ulp_u;
        else{
            par[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }

    // union by size - more intuitive
    void union_by_size(int u, int v, size){
        int ulp_u = find(u);
        int ulp_v = find(v);

        if(ulp_u == ulp_v) return;
        if(size[ulp_u] < size[ulp_v]) {
            par[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else{
            par[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }

};

// Krushkals MST
class Solution{
	public:
	
	int find(vector<int>& par,int X){
        if(X == par[X]) return X;
        return par[X] = find(par, par[X]);        //path compression - O(4a)=<O(1)
    }
    
    void union_by_size(vector<int>&size,vector<int>&par, int u, int v){
        int ulp_u = find(par,u);
        int ulp_v = find(par,v);

        if(ulp_u == ulp_v) return;
        if(size[ulp_u] < size[ulp_v]) {
            par[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else{
            par[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
	
    int spanningTree(int V, vector<vector<int>> adj[]){
        vector<vector<int>>edges;
        vector<int>par(V,0), size(V,0);
        for(int v = 0; v < V; v++){
            par[v] = v; size[v] = 1;
            for(auto i: adj[v]){
                int u = i[0];
                int wt = i[1];
                edges.push_back(vector<int>{wt,v,u});       //undirected so each edge multiple times, but since the vertices when encountered 2nd time have the same par - no change
            }
        }
        
        sort(edges.begin(), edges.end());
        
        int ans= 0;
        for(auto edge: edges){
            int wt = edge[0], v = edge[1],u = edge[2];
            
            int ulp_u = find(par, u);
            int ulp_v = find(par, v);
            if(ulp_u != ulp_v){
                union_by_size(size,par, u , v);
                ans += wt;
            }
        }
        return ans;
    }
};

class Solution{
	public:
	int find(int u, vector<int>& par){
	    if(u == par[u])return u;
	    find(par[u],par);
	}
	
	bool Union(int u, int v, vector<int>& size, vector<int>& par){
	    int p_u = find(u, par);
	    int p_v = find(v, par);
	    if(p_u == p_v)return false;
	  
	    if(size[p_u] < size[p_v]) par[p_u] = p_v;
 	    else par[p_v] = p_u;
 	    if(size[p_u] == size[p_v]) size[p_u]++;
 	    
 	    return true;
	}
	
    int spanningTree(int V, vector<vector<int>> adj[]){
        int ans = 0;
        vector<int>par(V,0), size(V,1);
        for(int i = 0; i < V; i++) par[i] = i;
        
        set<vector<int>>edges;
        for(int u = 0; u < V; u++){
            for(int v = 0; v < adj[u].size(); v++){
                int i = min(u, adj[u][v][0]);
                int j = max(u, adj[u][v][0]);
                edges.insert({adj[u][v][1], i, j});
            }
        }
        
        vector<vector<int>>edges_sorted(edges.begin(), edges.end());
        sort(edges_sorted.begin(), edges_sorted.end());
        
        for(int i = 0; i < edges_sorted.size(); i++){
            if(Union(edges_sorted[i][1], edges_sorted[i][2], size, par)) ans += edges_sorted[i][0];
        }

        return ans;
    }
};